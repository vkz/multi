
#+PROPERTY: header-args :results table raw prepend value :cache no

* require

Load benchmarking code

#+begin_src emacs-lisp :results output silent
(load-file "test-bench.el")
#+end_src

* multi-patterns

Load multi-patterns

#+begin_src emacs-lisp :results output silent
(load-file "../multi-patterns.el")
#+end_src

** relative performance

How does pattern-matching compare to the existing semantically similar solutions.
E.g. manual destructuring, seq-* functions, dash, etc. Idea is to have baseline
perf we should strive for and to give users some idea about perf so they can
decide if its good enough for them.

*** basic mu-case vs pcase

#+begin_src emacs-lisp
  (mu-bench*
    :compare t
    ("multi-case" (let* ((test-cases '(() (1) (1 2) (1 2 3) (1 2 3 4)))
                         (len (length test-cases))
                         (test-case (lambda () (nth (random len) test-cases))))
                    (mu-case (funcall test-case)
                      ((lst) 0)
                      ((lst _) 1)
                      ((lst _ _) 2)
                      ((lst _ _ _) 3)
                      (otherwise 'many))))
    ("pcase" (let* ((test-cases '(() (1) (1 2) (1 2 3) (1 2 3 4)))
                    (len (length test-cases))
                    (test-case (lambda () (nth (random len) test-cases))))
               (pcase (funcall test-case)
                 (`nil 0)
                 (`(,_) 1)
                 (`(,_ ,_) 2)
                 (`(,_ ,_ ,_) 3)
                 (otherwise 'many)))))
#+end_src

#+RESULTS:
| Form       | x slower | Total time | GCs | GC time | Timestamp                |
|------------+----------+------------+-----+---------+--------------------------|
| pcase      |     1.00 |   0.001325 |   0 |     0.0 | Thu Dec 27 08:41:01 2018 |
| multi-case |     1.56 |   0.002069 |   0 |     0.0 | Thu Dec 27 08:41:01 2018 |

*** mu-let

mu-let is terribly slow and triggers GC

#+begin_src emacs-lisp
  (mu-bench*
    :compare t
    ("seq-let" (mapcar
                (lambda (arg)
                  (seq-let (s1 &rest d) arg
                    (seq-let (a &rest t2) s1
                      (seq-let (b c) (seq-elt t2 0)
                        (list a b c d)))))
                (list '((1 (2 3)) 4) [[1 [2 3]] 4])))

    ("mu-let" (mapcar
               (lambda (arg)
                 (mu-let (([[a &rest [[b c]]] &rest d] arg))
                   (list a b c d)))
               (list '((1 (2 3)) 4) [[1 [2 3]] 4])))

    ("mu-case" (mapcar
                (lambda (arg)
                  (mu-case arg
                    ([[a &rest [[b c]]] &rest d] (list a b c d))))
                (list '((1 (2 3)) 4) [[1 [2 3]] 4]))))
#+end_src

#+RESULTS:
| Form    | x slower | Total time | GCs |  GC time | Timestamp                |
|---------+----------+------------+-----+----------+--------------------------|
| seq-let |     1.00 |   0.031043 |   0 | 0.000000 | Thu Dec 27 08:44:16 2018 |
| mu-case |     8.04 |   0.249537 |   0 | 0.000000 | Thu Dec 27 08:44:16 2018 |
| mu-let  |    20.46 |   0.635143 |   1 | 0.099905 | Thu Dec 27 08:44:16 2018 |


#+begin_src emacs-lisp
  (mu-bench*
    :compare t
    ("seq-let" (let* ((a 1))
                 (seq-let (b) '(2 3)
                   (seq-let (c d e) '(3 4)
                     (list a b c d e)))))

    ("mu-let" (mu-let ((a 1)
                       ([b] '(2 3))
                       ([c d e] '(3 4)))
                (list a b c d e))))
#+end_src

#+RESULTS:
| Form    | x slower | Total time | GCs |  GC time | Timestamp                |
|---------+----------+------------+-----+----------+--------------------------|
| seq-let |     1.00 |   0.005221 |   0 | 0.000000 | Thu Dec 27 08:45:38 2018 |
| mu-let  |    44.47 |   0.232198 |   0 | 0.000000 | Thu Dec 27 08:45:38 2018 |

*** ht-pattern vs ht|alist-get

#+begin_src emacs-lisp
  (mu-bench*
    :compare t
    ("ht-get" (let* ((table (ht (:a 1) ('b 2) (:c 3) ('d 4)))
                     (a (ht-get table :a))
                     (b (ht-get table 'b))
                     (c (ht-get table :c))
                     (D (ht-get table 'd)))
                (list a b c D)))

    ("ht-pattern" (mu-case (ht (:a 1) ('b 2) (:c 3) ('d 4))
                    ;; NOTE this one is richer than the ht-get version cause
                    ;; it tries different keys :a 'a "a" in order
                    ((ht :a b 'c ('d D)) (list a b c D)))))
#+end_src

#+RESULTS:
| Form       | x slower | Total time | GCs |  GC time | Timestamp                |
|------------+----------+------------+-----+----------+--------------------------|
| ht-pattern |     1.00 |   0.130536 |   1 | 0.095632 | Thu Dec 27 08:46:47 2018 |
| ht-get     |     1.05 |   0.137433 |   1 | 0.101954 | Thu Dec 27 08:46:47 2018 |


#+begin_src emacs-lisp
  (mu-bench*
    :compare t
    ("ht-get" (let* ((l (list (ht (:a 1)) '((:b . 2))))
                     (a (ht-get (car l) :a))
                     (b (alist-get :b (cadr l))))
                (list a b)))

    ("ht-pattern" (mu-case (list (ht (:a 1)) '((:b . 2)))
                    ((l (ht :a) (ht b)) (list a b)))))
#+end_src

#+RESULTS:
| Form       | x slower | Total time | GCs |  GC time | Timestamp                |
|------------+----------+------------+-----+----------+--------------------------|
| ht-get     |     1.00 |   0.118207 |   1 | 0.096840 | Thu Dec 27 08:47:22 2018 |
| ht-pattern |     1.07 |   0.126853 |   1 | 0.102074 | Thu Dec 27 08:47:22 2018 |

*** mu-lambda vs lambda

#+begin_src emacs-lisp
  (mu-bench*
    :compare t
    ("lambda" (let ((fun (lambda () t)))
                (funcall fun)))

    ("mu-lambda" (let ((fun (mu [] t)))
                   (funcall fun))))
#+end_src

#+RESULTS:
| Form      | x slower | Total time | GCs |  GC time | Timestamp                |
|-----------+----------+------------+-----+----------+--------------------------|
| lambda    |     1.00 |   0.000499 |   0 | 0.000000 | Thu Dec 27 08:48:50 2018 |
| mu-lambda |     1.22 |   0.000609 |   0 | 0.000000 | Thu Dec 27 08:48:50 2018 |

I don't think this is apples to apples comparison, need a better bench.

#+begin_src emacs-lisp
  (mu-bench*
    :compare t
    ("lambda" (funcall (lambda (a b &rest args) (list* a b args)) 1 2 3 4))
    ("mu-lambda" (funcall (mu [a b | args] (list* a b args)) 1 2 3 4)))
#+end_src

#+RESULTS:
| Form      | x slower | Total time | GCs |  GC time | Timestamp                |
|-----------+----------+------------+-----+----------+--------------------------|
| lambda    |     1.00 |   0.000718 |   0 | 0.000000 | Thu Dec 27 08:49:00 2018 |
| mu-lambda |   161.32 |   0.115828 |   0 | 0.000000 | Thu Dec 27 08:49:00 2018 |

#+begin_src emacs-lisp
  (mu-bench*
    :compare t
    ("lambda" (let ((fun (lambda (&rest args)
                           (pcase args
                             ((or `(,a ,b) `[,a ,b]) (list a b))
                             ((or `(,a ,b ,c) `[,a ,b ,c]) (list a b c))))))
                (list (funcall fun 1 2)
                      (funcall fun 1 2 3))))

    ("mu-lambda" (let ((fun (mu _
                              ([a b] (list a b))
                              ([a b c] (list a b c)))))
                   (list (funcall fun 1 2)
                         (funcall fun 1 2 3)))))
#+end_src

#+RESULTS:
| Form      | x slower | Total time | GCs |  GC time | Timestamp                |
|-----------+----------+------------+-----+----------+--------------------------|
| mu-lambda |     1.00 |   0.003443 |   0 | 0.000000 | Thu Dec 27 08:50:05 2018 |
| lambda    |     1.01 |   0.003485 |   0 | 0.000000 | Thu Dec 27 08:50:05 2018 |

** absolute performance

Benchmarks to track perf improvements and spot regressions. Ideally we should cover a wide variaty of patterns in every API bell-n-whistle we expose.

*** basic patterns

#+begin_src emacs-lisp
  (mu-bench
    (mapcar
     (lambda (arg)
       (mu-case arg
         ((lst) 0)
         ((lst _) 1)
         ((lst _ _) 2)
         ((lst _ _ _) 3)
         (otherwise 'many)))
     '(() (1) (1 2) (1 2 3) (1 2 3 4))))
#+end_src

#+RESULTS:
| Total time | GCs | GC time | Timestamp                |
|------------+-----+---------+--------------------------|
|   0.007033 |   0 |     0.0 | Thu Dec 27 08:50:55 2018 |

*** deeply nested []-pattern

#+begin_src emacs-lisp
(mu-bench
  (mapcar
   (lambda (arg)
     (mu-case arg
       ([[a &rest [[b c]]] &rest d] (list a b c d))))
   (list '((1 (2 3)) 4) [[1 [2 3]] 4])))
#+end_src

#+RESULTS:
| Total time | GCs | GC time | Timestamp                |
|------------+-----+---------+--------------------------|
|   0.255855 |   0 |     0.0 | Thu Dec 27 08:51:25 2018 |


* multi-methods

Load multi-methods

#+begin_src emacs-lisp :results output silent
(load-file "../multi-methods.el")
#+end_src

As a running example we'll be using the following global hierachy:

#+begin_example
  :dot  ->  :square  ->  :rect   *-> :shape
            |                    ^
            |                    |
            *->  :parallelogram  *-> :multiangle
#+end_example

captured in the following function:

#+begin_src emacs-lisp :results output silent
  (defsubst mu--bench-reset-hierachy ()
    ;; reset global hierarchy
    (setq mu-global-hierarchy (make-mu-hierarchy))
    ;; install new relations
    (mu-rel :dot isa :square)
    (mu-rel :rect isa :shape)
    (mu-rel :square isa :rect)
    (mu-rel :square isa :parallelogram)
    (mu-rel :parallelogram isa :multiangle)
    (mu-rel :parallelogram isa :shape))
#+end_src

** relative performance

multimethods vs generic dispatch

#+begin_src emacs-lisp
  (cl-defstruct foo-struct-0)
  (cl-defstruct foo-struct-1)
  (cl-defstruct foo-struct-2)
  (cl-defstruct foo-struct-3)
  (cl-defstruct foo-struct-4)
  (cl-defstruct foo-struct-5)
  (cl-defstruct foo-struct-6)

  ;; multi
  (mu-defmulti foo-test #'type-of)
  (mu-defmethod foo-test (x) :when 'foo-struct-1 1)
  (mu-defmethod foo-test (x) :when 'foo-struct-2 2)
  (mu-defmethod foo-test (x) :when 'foo-struct-3 3)
  (mu-defmethod foo-test (x) :when 'foo-struct-4 4)
  (mu-defmethod foo-test (x) :when 'foo-struct-5 5)
  (mu-defmethod foo-test (x) :when 'foo-struct-6 6)
  (mu-defmethod foo-test (x) :when :default 0)

  ;; generic
  (cl-defgeneric foo-struct-test (s) 0)
  (cl-defmethod foo-struct-test ((s foo-struct-1)) 1)
  (cl-defmethod foo-struct-test ((s foo-struct-2)) 2)
  (cl-defmethod foo-struct-test ((s foo-struct-3)) 3)
  (cl-defmethod foo-struct-test ((s foo-struct-4)) 4)
  (cl-defmethod foo-struct-test ((s foo-struct-5)) 5)
  (cl-defmethod foo-struct-test ((s foo-struct-6)) 6)

  (mu-bench*/let ((s0 (make-foo-struct-0))
                  (s1 (make-foo-struct-1))
                  (s2 (make-foo-struct-2))
                  (s3 (make-foo-struct-3))
                  (s4 (make-foo-struct-4))
                  (s5 (make-foo-struct-5))
                  (s6 (make-foo-struct-6)))
    :compare t
    (:generic (foo-struct-test s0)
              (foo-struct-test s1)
              (foo-struct-test s2)
              (foo-struct-test s3)
              (foo-struct-test s4)
              (foo-struct-test s5)
              (foo-struct-test s6))

    (:mu-method (foo-test s0)
                (foo-test s1)
                (foo-test s2)
                (foo-test s3)
                (foo-test s4)
                (foo-test s5)
                (foo-test s6)))
#+end_src

#+RESULTS:
| Form       | x slower | Total time | GCs |  GC time | Timestamp                |
|------------+----------+------------+-----+----------+--------------------------|
| :generic   |     1.00 |   0.020529 |   0 | 0.000000 | Thu Dec 27 10:49:29 2018 |
| :mu-method |   219.09 |   4.497643 |  27 | 2.535174 | Thu Dec 27 10:49:29 2018 |

** absolute performance

basic isa lookup

#+begin_src emacs-lisp
  (mu--bench-reset-hierachy)

  (mu-bench*
    :times 1000
    :compare t
    (:equal    (mu-isa? 42 42))
    (:direct   (mu-isa? :rect   :shape))
    (:indirect (mu-isa? :square :shape))
    (:seq1     (mu-isa? [:square :rect]  [:rect :shape]))
    (:seq2     (mu-isa? [:square :shape] [:rect :shape]))
    (:nested   (mu-isa? [[:dot :parallelogram] :square] [[:shape :multiangle] :rect])))
#+end_src

#+RESULTS:
| Form      | x slower | Total time | GCs |  GC time | Timestamp                |
|-----------+----------+------------+-----+----------+--------------------------|
| :equal    |     1.00 |   0.000477 |   0 | 0.000000 | Thu Dec 27 11:45:38 2018 |
| :direct   |     7.61 |   0.003632 |   0 | 0.000000 | Thu Dec 27 11:45:38 2018 |
| :indirect |     8.75 |   0.004175 |   0 | 0.000000 | Thu Dec 27 11:45:38 2018 |
| :seq2     |    15.37 |   0.007332 |   0 | 0.000000 | Thu Dec 27 11:45:38 2018 |
| :seq1     |    22.34 |   0.010657 |   0 | 0.000000 | Thu Dec 27 11:45:38 2018 |
| :nested   |    42.18 |   0.020122 |   0 | 0.000000 | Thu Dec 27 11:45:38 2018 |

dispatch on equality - no deep isa hierarchy traversal

#+begin_src emacs-lisp
  (mu-defmulti foo (lambda (&rest args) (apply #'vector args)))
  (mu-defmethod foo (&rest x) :when [:a] :a)
  (mu-defmethod foo (&rest x) :when [:b] :b)
  (mu-defmethod foo (&rest x) :when [:a :a] :a)
  (mu-defmethod foo (&rest x) :when [:a :b] :b)

  (mu-bench*
    :times 1000
    :compare t
    (:a (foo :a))
    (:b (foo :b))
    (:a-a (foo :a :a))
    (:b-b (foo :a :b)))
#+end_src

#+RESULTS:
| Form | x slower | Total time | GCs |  GC time | Timestamp                |
|------+----------+------------+-----+----------+--------------------------|
| :a   |     1.00 |   0.018426 |   0 | 0.000000 | Thu Dec 27 10:35:22 2018 |
| :a-a |     1.04 |   0.019175 |   0 | 0.000000 | Thu Dec 27 10:35:22 2018 |
| :b-b |     1.04 |   0.019238 |   0 | 0.000000 | Thu Dec 27 10:35:22 2018 |
| :b   |     1.05 |   0.019259 |   0 | 0.000000 | Thu Dec 27 10:35:22 2018 |

Hierarchies are rarely used, so most cache benefit comes from avoiding to isa with every registered method (0-20 in this example). The more methods we register the more overhead choosing the one becomes. Keep in mind: cache may overflow if most of the time you go to the :default method, so need to think of cache excision eventually.

#+begin_src emacs-lisp

  (mu-defmulti foo #'identity)
  (mu-defmethod foo (&rest args) :when 0  0)
  (mu-defmethod foo (&rest args) :when 1  1)
  (mu-defmethod foo (&rest args) :when 2  2)
  (mu-defmethod foo (&rest args) :when 3  3)
  (mu-defmethod foo (&rest args) :when 4  4)
  (mu-defmethod foo (&rest args) :when 5  5)
  (mu-defmethod foo (&rest args) :when 6  6)
  (mu-defmethod foo (&rest args) :when 7  7)
  (mu-defmethod foo (&rest args) :when 8  8)
  (mu-defmethod foo (&rest args) :when 9  9)
  (mu-defmethod foo (&rest args) :when 10 10)
  (mu-defmethod foo (&rest args) :when 11 11)
  (mu-defmethod foo (&rest args) :when 12 12)
  (mu-defmethod foo (&rest args) :when 13 13)
  (mu-defmethod foo (&rest args) :when 14 14)
  (mu-defmethod foo (&rest args) :when 15 15)
  (mu-defmethod foo (&rest args) :when 16 16)
  (mu-defmethod foo (&rest args) :when 17 17)
  (mu-defmethod foo (&rest args) :when 18 18)
  (mu-defmethod foo (&rest args) :when 19 19)
  (mu-defmethod foo (&rest args) :when 20 20)

  (mu-bench/let ((random20 (byte-compile (lambda () (random 21)))))
    (foo (funcall random20)))
#+end_src

#+RESULTS:
| Total time | GCs |            GC time | Timestamp                |
|------------+-----+--------------------+--------------------------|
|   1.420547 |   8 | 0.7918730000000096 | Thu Dec 27 11:43:49 2018 |

* locals

# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
