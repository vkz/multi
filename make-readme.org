#+OPTIONS: author:nil
#+OPTIONS: toc:nil
#+OPTIONS: prop:nil
#+OPTIONS: d:nil

#+EXPORT_FILE_NAME: README.org
#+TITLE: Multi-methods and multi-patterns for Emacs Lisp

#+PROPERTY: header-args :exports code :results none :cache no
#+PROPERTY: header-args:emacs-lisp :tangle ./test-readme.el
#+PROPERTY: header-args:emacs-lisp+ :noeval

* multi-dispatch

* multi-patterns

Choice vs destructuring.

Language of patterns: atom, list, standard pcase patterns, l-pattern, v-pattern, seq-patterns, overloading [], &rest pattern, ht-pattern.

** mu-case

examples

** mu-let

Semantics of [] seq-pattern

mu-let, mu-when-let, mu-if-let

** mu-defun

Simple single-head mu-defun

Multi-head mu-defun

Attributes

Defining or adding gv-setter

** mu-defmacro

** mu-defpattern

* multi-methods

** multi-hierarchies

** mu-defmulti

** mu-defmethod


* make-readme                                                      :noexport:

Simply run: =M-x org-babel-execute-buffer=

#+begin_src emacs-lisp :exports none :results output silent :eval yes :tangle no
  (defun mu-tangle-example ()
    (goto-char (point-min))
    (when (search-forward "=>" nil t)
      (goto-char (point-min))
      (let ((code nil))
        (condition-case eof
            (while t (push (read (current-buffer)) code))
          (end-of-file nil))
        (setq code (nreverse code))
        (erase-buffer)
        (dolist (ex (mapcar (lambda (e) (cons 'example e)) (seq-partition code 3)))
          (insert (pp-to-string ex))
          (newline)
          (newline)))))

  ;; hook that tangles an example into ert-tests
  (add-hook 'org-babel-tangle-body-hook #'mu-tangle-example)
  (message "README: `org-babel-tangle-body-hook' has been updated with `mu-tangle-example'")

  ;; export to README.org
  (require 'ox)
  (org-export-to-file 'org "README.org")

  ;; tangle examples into ert-tests
  (org-babel-tangle)

  ;; load tests
  (load-file "test-readme.el")

  ;; run tests
  (if noninteractive
      ;; exit emacs with 0 or 1 error-code
      (ert-run-tests-batch-and-exit nil)
    ;; test and show summary
    (ert t)
    (pop-to-buffer "*ert*"))
#+end_src

* test-readme                                                      :noexport:

#+begin_src emacs-lisp :exports none
  ;; -*- lexical-binding: t; -*-

  (require 'ert)
  (load-file "multi-patterns.el")

  (ert-delete-all-tests)

  (defmacro example (test _ expected)
    `(ert-deftest ,(intern (symbol-name (gensym "example"))) ()
       "test"
       (should (equal ,expected ,test))))

#+end_src

* Example

#+begin_src emacs-lisp

  (mu-case '(a b c)
    ((l 'a &rest tail) tail))
  =>
  '(b c)

#+end_src

* pcase

TIL that trying to compile anything with `pcase` matching in it may lead to an explosion of code generated during expansion. Even the most innocent looking patterns may generate hundreds of branches and thousands of lines of code. TBH I would never have noticed had it not been for a small macro I wrote yesterday. The exact code is unimportant but the gist of it is that it had a `pcase` with 4 clauses doing some matching on lists and what not. That macro was the last in the project I've been working on, so naturally I attempted to `byte-compile`. Upon reaching the macro the compiler would just sit there. Out of curiosity I let it - only to be disappointed with **Error: Bytecode overflow** some 10min later. O..K..

`M-x pp-macroexpand-all-last-sexp` ... 160K lines of expanded code later I was enlightened. If you ever looked at what `pcase` list pattern expands into, you wouldn't be surprised. There isn't any magic there, the rewriting rule is straightforward. Problem is it doesn't scale if you perform full macro-expansion, and IIUC that is what `byte-compile` does. Let's use a tiny contrived example just to get the feel for "scale":

    (pcase e
      (`(,a ,(or (or `(0) `[0]) 42)) a))

Full expansion of this is 70 lines of pretty-printed code but you can imagine how a bunch of nested patterns and several clauses create all possible permutations and baloon into thousands. My first thought was that it's the `(or .. ..)` pattern that's not cleverly handled and replacing it with explicit clauses may help fight branching:

(pcase e
  (`(,a (0)) a)
  (`(,a [0]) a)
  (`(,a 42) a))

Well, macroexpand-all and you get the exact same 70 loc, so, yeah, they're precisely equivalent. I bet `pcase` actually re-writse one into the other.

It isn't a problem at runtime i.e. if you just eval and run the interpreter, because in 99.9% of cases the match fails at the head, so all those branches never get generated by the expander when you just interpret and match. That's why I never noticed any issues say with performance.

I guess I have several questions after this long-winded diatribe:

1. How do you `byte-compile` code that uses `pcase`?
2. Maybe you don't compile, but then how do you get reasonable performance?
3. Maybe you just don't use `pcase` ever? Is this why so much Elisp is poisoned with `caddaar` and friends? I really want my pattern matching.
4. Is there anything obvious I've overlooked?

Didn't get any relevant hits searching emacs-devel archives.

* Another example

#+begin_src emacs-lisp

  (mu-case '(a b c)
    ((l 'a &rest tail) tail))
  =>
  '(b c)

#+end_src
